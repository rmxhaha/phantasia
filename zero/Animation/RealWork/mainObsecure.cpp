#include <iostream>#include <cmath>#include <vector>using namespace std;namespace Fx {	enum transition_t	{		CONSTANT_ANIMATION,		DEACCEL_ANIMATION,		ACCEL_ANIMATION	};	template< class T = float >class tween;	template< class T = float >class const_tween;	template< class T = float >class accel_tween;	template< class T = float >class deaccel_tween;	class tween {	public:		tween( T& elem, T delta_data, float animation_time, float delay_time = 0.f ) {			this -> now_time = 0.f;			this -> delta_data = delta_data;			this -> element = &elem;			this -> animation_time = animation_time;			this -> delay_time = delay_time;		}		void update( float dt ){			if( delay_time - dt >= 0.f ) {				delay_time = delay_time - dt;			} else {				calculate( dt );			}		}	private:		virtual void calculate( float dt ){			if( now_time >= animation_time ) return;			if( now_time + dt > animation_time ){				dt = animation_time - now_time;			}			/*			switch( trans ) {				case CONSTANT_ANIMATION:					*element += dt * delta_data / animation_time;					break;				case DEACCEL_ANIMATION:					*element += delta_data * ( pow( now_time + dt,2 ) - pow( now_time, 2 ) ) / animation_time / animation_time;					break;				case ACCEL_ANIMATION:					*element += delta_data * ( pow( animation_time - now_time, 2 ) - pow( animation_time - now_time - dt, 2 ) ) / animation_time / animation_time;					break;			}			*/			now_time += dt;		}	public:		bool isRunning() const {			return ( delay_time > 0.f || now_time < animation_time );		}	private:		T * element;		T delta_data;		float delay_time;		float now_time;		float animation_time;		friend class const_tween;		friend class deaccel_tween;		friend class accel_tween;	};	template<class T = float> class const_tween : public tween<> {	public:		explicit const_tween( T& elem, T delta_data, float animation_time, float delay_time = 0.f ) : tween<>( elem, delta_data, animation_time, delay_time ) {}	private:		void calculate( float dt ){			if( now_time >= animation_time ) return;			if( now_time + dt > animation_time ){				dt = animation_time - now_time;			}			*element += dt * delta_data / animation_time;			now_time += dt;		}	};	template<class T = float> class accel_tween : public tween<> {		accel_tween() : tween<>() {} //inherit constructor		void calculate( float dt ){			if( now_time >= animation_time ) return;			if( now_time + dt > animation_time ){				dt = animation_time - now_time;			}			*element += delta_data * ( pow( animation_time - now_time, 2 ) - pow( animation_time - now_time - dt, 2 ) ) / animation_time / animation_time;			now_time += dt;		}	};	template<class T = float> class deaccel_tween : public tween<> {		deaccel_tween() : tween<>() {} //inherit constructor		void calculate( float dt ){			if( now_time >= animation_time ) return;			if( now_time + dt > animation_time ){				dt = animation_time - now_time;			}			*element += delta_data * ( pow( now_time + dt,2 ) - pow( now_time, 2 ) ) / animation_time / animation_time;			now_time += dt;		}	};	template<class T> void new_tween( T& elem, T delta_data, float delay_time ){	}	void Handle() {		/* Animation */	}}int main() {	float p = 0.f;	Fx::const_tween<float> animation( p, 1000.f, 1.f );	for( int i =0 ;i < 10; i++ ){		animation.update( 0.1f );		cout << p << endl;	}	return 0;}